{"version":3,"file":"static/js/520.2479a684.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","../node_modules/pixi.js/src/scene/sprite-tiling/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","../node_modules/pixi.js/src/app/ResizePlugin.ts","../node_modules/pixi.js/src/app/TickerPlugin.ts","../node_modules/pixi.js/src/app/init.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","../node_modules/pixi.js/src/scene/graphics/init.ts","../node_modules/pixi.js/src/scene/text/canvas/utils/fontStringFromTextStyle.ts","../node_modules/pixi.js/src/scene/text/TextStyle.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","../node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","../node_modules/pixi.js/src/scene/text/init.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","../node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts","../node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts","../node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts","../node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","../node_modules/pixi.js/src/scene/text-bitmap/init.ts","../node_modules/pixi.js/src/scene/text/utils/generateTextStyleKey.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","../node_modules/pixi.js/src/scene/mesh/init.ts","../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts","../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","../node_modules/pixi.js/src/filters/FilterPipe.ts","../node_modules/pixi.js/src/filters/FilterSystem.ts","../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts","../node_modules/pixi.js/src/filters/init.ts","../node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts","../node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/init.ts","../node_modules/pixi.js/src/scene/text/canvas/utils/getCanvasFillStyle.ts","../node_modules/pixi.js/src/scene/text/utils/updateTextBounds.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextMetrics.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","../node_modules/pixi.js/src/scene/text-html/utils/textStyleToCSS.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextStyle.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","../node_modules/pixi.js/src/utils/browser/isSafari.ts","../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","../node_modules/pixi.js/src/scene/text-html/init.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts"],"sourcesContent":["export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","export const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            } \n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n        \n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n        \n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n    \n        `\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Container } from '../container/Container';\nimport type { TilingSprite } from './TilingSprite';\n\ninterface RenderableData\n{\n    canBatch: boolean;\n    renderable: TilingSprite\n    batchableMesh?: BatchableMesh;\n    geometry?: MeshGeometry;\n    shader?: TilingSpriteShader;\n}\n\nconst sharedQuad = new QuadGeometry();\n\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n    private readonly _tilingSpriteDataHash: Record<number, RenderableData> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_tilingSpriteDataHash');\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                renderable.texture\n            );\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.setTexture(tilingSprite._texture);\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._tilingSpriteDataHash[tilingSprite.uid];\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    public destroyRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        tilingSpriteData.batchableMesh = null;\n\n        tilingSpriteData.shader?.destroy();\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = null;\n\n        tilingSprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): RenderableData\n    {\n        return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): RenderableData\n    {\n        const geometry = new MeshGeometry({\n            indices: sharedQuad.indices,\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n\n        this._tilingSpriteDataHash[tilingSprite.uid] = {\n            canBatch: true,\n            renderable: tilingSprite,\n            geometry,\n        };\n\n        tilingSprite.on('destroyed', this._destroyRenderableBound);\n\n        return this._tilingSpriteDataHash[tilingSprite.uid];\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        for (const i in this._tilingSpriteDataHash)\n        {\n            this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);\n        }\n\n        (this._tilingSpriteDataHash as null) = null;\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite.applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n    public _textureMatrixUpdateId: number = -1;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    /**\n     * Sets the texture for the batchable mesh.\n     * As it does so, it resets the texture matrix update ID.\n     * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n     * @param value - The texture to set.\n     */\n    public setTexture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link app.ResizePlugin}.\n * @memberof app\n * @property {Window|HTMLElement} [resizeTo=window] - Element to automatically resize the renderer to.\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @memberof app.ApplicationOptions\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#resizeTo}\n * * {@link app.Application#resize}\n * * {@link app.Application#queueResize}\n * * {@link app.Application#cancelResize}\n * @example\n * import { extensions, ResizePlugin } from 'pixi.js';\n *\n * extensions.add(ResizePlugin);\n * @memberof app\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static resizeTo: Window | HTMLElement;\n    public static resize: () => void;\n    public static renderer: ResizeableRenderer;\n    public static queueResize: () => void;\n    public static render: () => void;\n    private static _resizeId: number;\n    private static _resizeTo: Window | HTMLElement;\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            /**\n             * The HTML element or window to automatically resize the\n             * renderer's view element to match width and height.\n             * @member {Window|HTMLElement}\n             * @name resizeTo\n             * @memberof app.Application#\n             */\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        /**\n         * Resize is throttled, so it's safe to call this multiple times per frame and it'll\n         * only be called once.\n         * @memberof app.Application#\n         * @method queueResize\n         * @private\n         */\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        /**\n         * Cancel the resize queue.\n         * @memberof app.Application#\n         * @method cancelResize\n         * @private\n         */\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        /**\n         * Execute an immediate resize on the renderer, this is not\n         * throttled and can be expensive to call many times in a row.\n         * Will resize only if `resizeTo` property is set.\n         * @memberof app.Application#\n         * @method resize\n         */\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link app.TickerPlugin}.\n * @memberof app\n * @property {boolean} [autoStart=true] - Automatically starts the rendering after the construction.\n * **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n * `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n * @property {boolean} [sharedTicker=false] - Set`true` to use `Ticker.shared`, `false` to create new ticker.\n * If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n * The system ticker will always run before both the shared ticker and the app ticker.\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Automatically starts the rendering after the construction.\n     *  **Note**: Setting this parameter to `false` does NOT stop the shared ticker even if you set\n     *  `options.sharedTicker` to `true` in case that it is already started. Stop it by your own.\n     * @memberof app.ApplicationOptions\n     * @default true\n     */\n    autoStart?: boolean;\n    /**\n     * Set`true` to use `Ticker.shared`, `false` to create new ticker.\n     *  If set to `false`, you cannot register a handler to occur before anything that runs on the shared ticker.\n     *  The system ticker will always run before both the shared ticker and the app ticker.\n     * @memberof app.ApplicationOptions\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link ticker.Ticker} functionality.\n *\n * Adds the following methods to {@link app.Application}:\n * * {@link app.Application#start}\n * * {@link app.Application#stop}\n * * {@link app.Application#ticker}\n * @example\n * import { extensions, TickerPlugin } from 'pixi.js';\n *\n * extensions.add(TickerPlugin);\n * @memberof app\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    public static start: () => void;\n    public static stop: () => void;\n    private static _ticker: Ticker;\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @static\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        /**\n         * Convenience method for stopping the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        /**\n         * Convenience method for starting the render.\n         * @method\n         * @memberof app.Application\n         * @instance\n         */\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        /**\n         * Internal reference to the ticker.\n         * @type {Ticker}\n         * @name _ticker\n         * @memberof app.Application#\n         * @private\n         */\n        this._ticker = null;\n\n        /**\n         * Ticker for doing render updates.\n         * @type {ticker.Ticker}\n         * @name ticker\n         * @memberof app.Application#\n         * @default Ticker.shared\n         */\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @static\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { RenderableGCSystem } from '../../../rendering/renderers/shared/texture/RenderableGCSystem';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext, GraphicsContextSystem } from './GraphicsContextSystem';\n\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    init(): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\nexport interface GraphicsSystem\n{\n    graphicsContext: GraphicsContextSystem;\n    renderableGC: RenderableGCSystem;\n    renderPipes: {\n        batch: BatchPipe\n    }\n    _roundPixels: 0 | 1;\n}\n\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: GraphicsSystem;\n    public state: State = State.for2d();\n\n    // batchable graphics list, used to render batches\n    private _graphicsBatchesHash: Record<number, BatchableGraphics[]> = Object.create(null);\n    private _adaptor: GraphicsAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: GraphicsSystem, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n        this._adaptor.init();\n\n        this.renderer.renderableGC.addManagedHash(this, '_graphicsBatchesHash');\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n\n        const context = graphics.context;\n\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const batches = this._graphicsBatchesHash[graphics.uid];\n\n        if (batches)\n        {\n            for (let i = 0; i < batches.length; i++)\n            {\n                const batch = batches[i];\n\n                batch._batcher.updateElement(batch);\n            }\n        }\n    }\n\n    public destroyRenderable(graphics: Graphics)\n    {\n        if (this._graphicsBatchesHash[graphics.uid])\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        graphics.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const wasBatched = !!this._graphicsBatchesHash[graphics.uid];\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // TODO POOL the old batches!\n\n        if (wasBatched)\n        {\n            this._removeBatchForRenderable(graphics.uid);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._initBatchesForRenderable(graphics);\n        }\n\n        graphics.batched = gpuContext.isBatchable;\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getBatchesForRenderable(graphics);\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);\n    }\n\n    private _initBatchesForRenderable(graphics: Graphics): BatchableGraphics[]\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        const batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n\n        if (this._graphicsBatchesHash[graphics.uid] === undefined)\n        {\n            // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n            graphics.on('destroyed', this._destroyRenderableBound);\n        }\n\n        this._graphicsBatchesHash[graphics.uid] = batches;\n\n        return batches;\n    }\n\n    private _removeBatchForRenderable(graphicsUid: number)\n    {\n        this._graphicsBatchesHash[graphicsUid].forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this._graphicsBatchesHash[graphicsUid] = null;\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n\n        for (const i in this._graphicsBatchesHash)\n        {\n            this._removeBatchForRenderable(i as unknown as number);\n        }\n\n        this._graphicsBatchesHash = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","import type { TextStyle } from '../../TextStyle';\n\nconst genericFontFamilies = [\n    'serif',\n    'sans-serif',\n    'monospace',\n    'cursive',\n    'fantasy',\n    'system-ui',\n];\n\n/**\n * Generates a font style string to use for `TextMetrics.measureFont()`.\n * @param style\n * @returns Font style string, for passing to `TextMetrics.measureFont()`\n */\nexport function fontStringFromTextStyle(style: TextStyle): string\n{\n    // build canvas api font setting from individual components. Convert a numeric style.fontSize to px\n    const fontSizeString = (typeof style.fontSize === 'number') ? `${style.fontSize}px` : style.fontSize;\n\n    // Clean-up fontFamily property by quoting each font name\n    // this will support font names with spaces\n    let fontFamilies: string | string[] = style.fontFamily;\n\n    if (!Array.isArray(style.fontFamily))\n    {\n        fontFamilies = style.fontFamily.split(',');\n    }\n\n    for (let i = fontFamilies.length - 1; i >= 0; i--)\n    {\n        // Trim any extra white-space\n        let fontFamily = fontFamilies[i].trim();\n\n        // Check if font already contains strings\n        if (!(/([\\\"\\'])[^\\'\\\"]+\\1/).test(fontFamily) && !genericFontFamilies.includes(fontFamily))\n        {\n            fontFamily = `\"${fontFamily}\"`;\n        }\n        (fontFamilies as string[])[i] = fontFamily;\n    }\n\n    // eslint-disable-next-line max-len\n    return `${style.fontStyle} ${style.fontVariant} ${style.fontWeight} ${fontSizeString} ${(fontFamilies as string[]).join(',')}`;\n}\n","import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { FillGradient } from '../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../graphics/shared/fill/FillPattern';\nimport { GraphicsContext } from '../graphics/shared/GraphicsContext';\nimport {\n    toFillStyle,\n    toStrokeStyle\n} from '../graphics/shared/utils/convertFillInputToFillStyle';\nimport { generateTextStyleKey } from './utils/generateTextStyleKey';\n\nimport type { TextureDestroyOptions, TypeOrBool } from '../container/destroyTypes';\nimport type {\n    ConvertedFillStyle,\n    ConvertedStrokeStyle,\n    FillInput,\n    FillStyle,\n    StrokeInput,\n    StrokeStyle\n} from '../graphics/shared/FillTypes';\n\nexport type TextStyleAlign = 'left' | 'center' | 'right' | 'justify';\nexport type TextStyleFill = string | string[] | number | number[] | CanvasGradient | CanvasPattern;\nexport type TextStyleFontStyle = 'normal' | 'italic' | 'oblique';\nexport type TextStyleFontVariant = 'normal' | 'small-caps';\n// eslint-disable-next-line max-len\nexport type TextStyleFontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\nexport type TextStyleLineJoin = 'miter' | 'round' | 'bevel';\nexport type TextStyleTextBaseline = 'alphabetic' | 'top' | 'hanging' | 'middle' | 'ideographic' | 'bottom';\nexport type TextStyleWhiteSpace = 'normal' | 'pre' | 'pre-line';\n\n/**\n * A collection of text related classes.\n * @namespace text\n */\n\n/**\n * A drop shadow effect.\n * @memberof text\n */\nexport type TextDropShadow = {\n    /** Set alpha for the drop shadow  */\n    alpha: number;\n    /** Set a angle of the drop shadow */\n    angle: number;\n    /** Set a shadow blur radius */\n    blur: number;\n    /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n    color: ColorSource;\n    /** Set a distance of the drop shadow */\n    distance: number;\n};\n\n/**\n * Constructor options used for `TextStyle` instances.\n * ```js\n * const textStyle = new TextStyle({\n *    fontSize: 12,\n *    fill: 'black',\n * });\n * ```\n * @see {@link text.TextStyle}\n * @memberof text\n */\nexport interface TextStyleOptions\n{\n    /**\n     * Alignment for multiline text, does not affect single line text\n     * @type {'left'|'center'|'right'|'justify'}\n     */\n    align?: TextStyleAlign;\n    /** Indicates if lines can be wrapped within words, it needs `wordWrap` to be set to `true` */\n    breakWords?: boolean;\n    /** Set a drop shadow for the text */\n    dropShadow?: boolean | Partial<TextDropShadow>;\n    /**\n     * A canvas fillstyle that will be used on the text e.g., 'red', '#00FF00'.\n     * Can be an array to create a gradient, e.g., `['#000000','#FFFFFF']`\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}\n     * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n     */\n    fill?: FillInput;\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    fontFamily?: string | string[];\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    fontSize?: number | string;\n    /**\n     * The font style.\n     * @type {'normal'|'italic'|'oblique'}\n     */\n    fontStyle?: TextStyleFontStyle;\n    /**\n     * The font variant.\n     * @type {'normal'|'small-caps'}\n     */\n    fontVariant?: TextStyleFontVariant;\n    /**\n     * The font weight.\n     * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    fontWeight?: TextStyleFontWeight;\n    /** The height of the line, a number that represents the vertical space that a letter uses. */\n    leading?: number;\n    /** The amount of spacing between letters, default is 0 */\n    letterSpacing?: number;\n    /** The line height, a number that represents the vertical space that a letter uses */\n    lineHeight?: number;\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from\n     * happening by adding padding to all sides of the text.\n     */\n    padding?: number;\n    /** A canvas fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00' */\n    stroke?: StrokeInput;\n    /**\n     * The baseline of the text that is rendered.\n     * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    textBaseline?: TextStyleTextBaseline;\n    trim?: boolean,\n    /**\n     * Determines whether newlines & spaces are collapsed or preserved \"normal\"\n     * (collapse, collapse), \"pre\" (preserve, preserve) | \"pre-line\" (preserve,\n     * collapse). It needs wordWrap to be set to true.\n     * @type {'normal'|'pre'|'pre-line'}\n     */\n    whiteSpace?: TextStyleWhiteSpace;\n    /** Indicates if word wrap should be used */\n    wordWrap?: boolean;\n    /** The width at which text will wrap, it needs wordWrap to be set to true */\n    wordWrapWidth?: number;\n}\n\n/**\n * A TextStyle Object contains information to decorate a Text objects.\n *\n * An instance can be shared between multiple Text objects; then changing the style will update all text objects using it.\n * @memberof text\n * @example\n * import { TextStyle } from 'pixi.js';\n * const style = new TextStyle({\n *   fontFamily: ['Helvetica', 'Arial', 'sans-serif'],\n *   fontSize: 36,\n * });\n */\nexport class TextStyle extends EventEmitter<{\n    update: TextDropShadow\n}>\n{\n    /** The default drop shadow settings */\n    public static defaultDropShadow: TextDropShadow = {\n        /** Set alpha for the drop shadow */\n        alpha: 1,\n        /** Set a angle of the drop shadow */\n        angle: Math.PI / 6,\n        /** Set a shadow blur radius */\n        blur: 0,\n        /** A fill style to be used on the  e.g., 'red', '#00FF00' */\n        color: 'black',\n        /** Set a distance of the drop shadow */\n        distance: 5,\n    };\n\n    /** The default text style settings */\n    public static defaultTextStyle: TextStyleOptions = {\n        /**\n         * See {@link TextStyle.align}\n         * @type {'left'|'center'|'right'|'justify'}\n         */\n        align: 'left',\n        /** See {@link TextStyle.breakWords} */\n        breakWords: false,\n        /** See {@link TextStyle.dropShadow} */\n        dropShadow:  null,\n        /**\n         * See {@link TextStyle.fill}\n         * @type {string|string[]|number|number[]|CanvasGradient|CanvasPattern}\n         */\n        fill: 'black',\n        /**\n         * See {@link TextStyle.fontFamily}\n         * @type {string|string[]}\n         */\n        fontFamily: 'Arial',\n        /**\n         * See {@link TextStyle.fontSize}\n         * @type {number|string}\n         */\n        fontSize: 26,\n        /**\n         * See {@link TextStyle.fontStyle}\n         * @type {'normal'|'italic'|'oblique'}\n         */\n        fontStyle: 'normal',\n        /**\n         * See {@link TextStyle.fontVariant}\n         * @type {'normal'|'small-caps'}\n         */\n        fontVariant: 'normal',\n        /**\n         * See {@link TextStyle.fontWeight}\n         * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n         */\n        fontWeight: 'normal',\n        /** See {@link TextStyle.leading} */\n        leading: 0,\n        /** See {@link TextStyle.letterSpacing} */\n        letterSpacing: 0,\n        /** See {@link TextStyle.lineHeight} */\n        lineHeight: 0,\n        /** See {@link TextStyle.padding} */\n        padding: 0,\n        /**\n         * See {@link TextStyle.stroke}\n         * @type {string|number}\n         */\n        stroke: null,\n        /**\n         * See {@link TextStyle.textBaseline}\n         * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n         */\n        textBaseline: 'alphabetic',\n        /** See {@link TextStyle.trim} */\n        trim: false,\n        /**\n         * See {@link TextStyle.whiteSpace}\n         * @type {'normal'|'pre'|'pre-line'}\n         */\n        whiteSpace: 'pre',\n        /** See {@link TextStyle.wordWrap} */\n        wordWrap: false,\n        /** See {@link TextStyle.wordWrapWidth} */\n        wordWrapWidth: 100,\n    };\n\n    // colors!!\n    public _fill: ConvertedFillStyle;\n    private _originalFill: FillInput;\n\n    public _stroke: ConvertedStrokeStyle;\n    private _originalStroke: StrokeInput;\n\n    private _dropShadow: TextDropShadow;\n\n    private _fontFamily: string | string[];\n    private _fontSize: number;\n    private _fontStyle: TextStyleFontStyle;\n    private _fontVariant: TextStyleFontVariant;\n    private _fontWeight: TextStyleFontWeight;\n\n    private _breakWords: boolean;\n    private _align: TextStyleAlign;\n    private _leading: number;\n    private _letterSpacing: number;\n    private _lineHeight: number;\n\n    private _textBaseline: TextStyleTextBaseline;\n    private _whiteSpace: TextStyleWhiteSpace;\n    private _wordWrap: boolean;\n    private _wordWrapWidth: number;\n\n    private _padding: number;\n\n    protected _styleKey: string;\n    private _trim: boolean;\n\n    constructor(style: Partial<TextStyleOptions> = {})\n    {\n        super();\n\n        convertV7Tov8Style(style);\n\n        const fullStyle = { ...TextStyle.defaultTextStyle, ...style };\n\n        for (const key in fullStyle)\n        {\n            const thisKey = key as keyof typeof this;\n\n            this[thisKey] = fullStyle[key as keyof TextStyleOptions] as any;\n        }\n\n        this.update();\n    }\n\n    /**\n     * Alignment for multiline text, does not affect single line text.\n     * @member {'left'|'center'|'right'|'justify'}\n     */\n    get align(): TextStyleAlign { return this._align; }\n    set align(value: TextStyleAlign) { this._align = value; this.update(); }\n    /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */\n    get breakWords(): boolean { return this._breakWords; }\n    set breakWords(value: boolean) { this._breakWords = value; this.update(); }\n    /** Set a drop shadow for the text. */\n    get dropShadow(): TextDropShadow { return this._dropShadow; }\n    set dropShadow(value: boolean | TextDropShadow)\n    {\n        if (value !== null && typeof value === 'object')\n        {\n            this._dropShadow = this._createProxy({ ...TextStyle.defaultDropShadow, ...value });\n        }\n        else\n        {\n            this._dropShadow = value ? this._createProxy({ ...TextStyle.defaultDropShadow }) : null;\n        }\n\n        this.update();\n    }\n    /** The font family, can be a single font name, or a list of names where the first is the preferred font. */\n    get fontFamily(): string | string[] { return this._fontFamily; }\n    set fontFamily(value: string | string[]) { this._fontFamily = value; this.update(); }\n    /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */\n    get fontSize(): number { return this._fontSize; }\n    set fontSize(value: string | number)\n    {\n        if (typeof value === 'string')\n        {\n            // eg '34px' to number\n            this._fontSize = parseInt(value as string, 10);\n        }\n        else\n        {\n            this._fontSize = value as number;\n        }\n        this.update();\n    }\n    /**\n     * The font style.\n     * @member {'normal'|'italic'|'oblique'}\n     */\n    get fontStyle(): TextStyleFontStyle { return this._fontStyle; }\n    set fontStyle(value: TextStyleFontStyle)\n    {\n        this._fontStyle = value.toLowerCase() as TextStyleFontStyle;\n        this.update();\n    }\n    /**\n     * The font variant.\n     * @member {'normal'|'small-caps'}\n     */\n    get fontVariant(): TextStyleFontVariant { return this._fontVariant; }\n    set fontVariant(value: TextStyleFontVariant) { this._fontVariant = value; this.update(); }\n    /**\n     * The font weight.\n     * @member {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}\n     */\n    get fontWeight(): TextStyleFontWeight { return this._fontWeight; }\n    set fontWeight(value: TextStyleFontWeight) { this._fontWeight = value; this.update(); }\n    /** The space between lines. */\n    get leading(): number { return this._leading; }\n    set leading(value: number) { this._leading = value; this.update(); }\n    /** The amount of spacing between letters, default is 0. */\n    get letterSpacing(): number { return this._letterSpacing; }\n    set letterSpacing(value: number) { this._letterSpacing = value; this.update(); }\n    /** The line height, a number that represents the vertical space that a letter uses. */\n    get lineHeight(): number { return this._lineHeight; }\n    set lineHeight(value: number) { this._lineHeight = value; this.update(); }\n    /**\n     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening\n     * by adding padding to all sides of the text.\n     */\n    get padding(): number { return this._padding; }\n    set padding(value: number) { this._padding = value; this.update(); }\n\n    /** Trim transparent borders. This is an expensive operation so only use this if you have to! */\n    get trim(): boolean { return this._trim; }\n    set trim(value: boolean) { this._trim = value; this.update(); }\n    /**\n     * The baseline of the text that is rendered.\n     * @member {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}\n     */\n    get textBaseline(): TextStyleTextBaseline { return this._textBaseline; }\n    set textBaseline(value: TextStyleTextBaseline) { this._textBaseline = value; this.update(); }\n    /**\n     * How newlines and spaces should be handled.\n     * Default is 'pre' (preserve, preserve).\n     *\n     *  value       | New lines     |   Spaces\n     *  ---         | ---           |   ---\n     * 'normal'     | Collapse      |   Collapse\n     * 'pre'        | Preserve      |   Preserve\n     * 'pre-line'   | Preserve      |   Collapse\n     * @member {'normal'|'pre'|'pre-line'}\n     */\n    get whiteSpace(): TextStyleWhiteSpace { return this._whiteSpace; }\n    set whiteSpace(value: TextStyleWhiteSpace) { this._whiteSpace = value; this.update(); }\n    /** Indicates if word wrap should be used. */\n    get wordWrap(): boolean { return this._wordWrap; }\n    set wordWrap(value: boolean) { this._wordWrap = value; this.update(); }\n    /** The width at which text will wrap, it needs wordWrap to be set to true. */\n    get wordWrapWidth(): number { return this._wordWrapWidth; }\n    set wordWrapWidth(value: number) { this._wordWrapWidth = value; this.update(); }\n\n    /**\n     * The fill style that will be used to color the text.\n     * This can be:\n     * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'\n     * - A hex number like 0xff0000 for red\n     * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }\n     * - A FillGradient for gradient fills\n     * - A FillPattern for pattern/texture fills\n     *\n     * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,\n     * while gradients at any other angle are spread across the entire text body as a whole.\n     * @example\n     * // Vertical gradient applied per line\n     * const verticalGradient = new FillGradient(0, 0, 0, 1)\n     *     .addColorStop(0, 0xff0000)\n     *     .addColorStop(1, 0x0000ff);\n     *\n     * const text = new Text({\n     *     text: 'Line 1\\nLine 2',\n     *     style: { fill: verticalGradient }\n     * });\n     *\n     * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.\n     * @type {string|number|FillStyle|FillGradient|FillPattern}\n     */\n    get fill(): FillInput\n    {\n        return this._originalFill;\n    }\n\n    set fill(value: FillInput)\n    {\n        if (value === this._originalFill) return;\n\n        this._originalFill = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalFill = this._createProxy({ ...GraphicsContext.defaultFillStyle, ...value }, () =>\n            {\n                this._fill = toFillStyle(\n                    { ...this._originalFill as FillStyle },\n                    GraphicsContext.defaultFillStyle\n                );\n            });\n        }\n\n        this._fill = toFillStyle(\n            value === 0x0 ? 'black' : value,\n            GraphicsContext.defaultFillStyle\n        );\n        this.update();\n    }\n\n    /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */\n    get stroke(): StrokeInput\n    {\n        return this._originalStroke;\n    }\n\n    set stroke(value: StrokeInput)\n    {\n        if (value === this._originalStroke) return;\n\n        this._originalStroke = value;\n\n        if (this._isFillStyle(value))\n        {\n            this._originalStroke = this._createProxy({ ...GraphicsContext.defaultStrokeStyle, ...value }, () =>\n            {\n                this._stroke = toStrokeStyle(\n                    { ...this._originalStroke as StrokeStyle },\n                    GraphicsContext.defaultStrokeStyle\n                );\n            });\n        }\n\n        this._stroke = toStrokeStyle(value, GraphicsContext.defaultStrokeStyle);\n        this.update();\n    }\n\n    protected _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this);\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._styleKey = null;\n        this.emit('update', this);\n    }\n\n    /** Resets all properties to the default values */\n    public reset()\n    {\n        const defaultStyle = TextStyle.defaultTextStyle;\n\n        for (const key in defaultStyle)\n        {\n            this[key as keyof typeof this] = defaultStyle[key as keyof TextStyleOptions] as any;\n        }\n    }\n\n    get styleKey()\n    {\n        return this._styleKey || this._generateKey();\n    }\n\n    /**\n     * Creates a new TextStyle object with the same values as this one.\n     * @returns New cloned TextStyle object\n     */\n    public clone(): TextStyle\n    {\n        return new TextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this._dropShadow ? { ...this._dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            leading: this.leading,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            textBaseline: this.textBaseline,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n        });\n    }\n\n    /**\n     * Destroys this text style.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the texture of the this style\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the this style\n     */\n    public destroy(options: TypeOrBool<TextureDestroyOptions> = false)\n    {\n        this.removeAllListeners();\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            if (this._fill?.texture)\n            {\n                this._fill.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalFill as FillStyle)?.texture)\n            {\n                (this._originalFill as FillStyle).texture.destroy(destroyTextureSource);\n            }\n\n            if (this._stroke?.texture)\n            {\n                this._stroke.texture.destroy(destroyTextureSource);\n            }\n\n            if ((this._originalStroke as FillStyle)?.texture)\n            {\n                (this._originalStroke as FillStyle).texture.destroy(destroyTextureSource);\n            }\n        }\n\n        this._fill = null;\n        this._stroke = null;\n        this.dropShadow = null;\n        this._originalStroke = null;\n        this._originalFill = null;\n    }\n\n    private _createProxy<T extends object>(value: T, cb?: (property: string, newValue: any) => void): T\n    {\n        return new Proxy<T>(value, {\n            set: (target, property, newValue) =>\n            {\n                target[property as keyof T] = newValue;\n                cb?.(property as string, newValue);\n                this.update();\n\n                return true;\n            }\n        });\n    }\n\n    private _isFillStyle(value: FillInput): value is FillStyle\n    {\n        return ((value ?? null) !== null\n            && !(Color.isColorLike(value) || value instanceof FillGradient || value instanceof FillPattern));\n    }\n}\n\nfunction convertV7Tov8Style(style: TextStyleOptions)\n{\n    const oldStyle = style as TextStyleOptions & {\n        dropShadowAlpha?: number;\n        dropShadowAngle?: number;\n        dropShadowBlur?: number;\n        dropShadowColor?: number;\n        dropShadowDistance?: number;\n        fillGradientStops?: number[];\n        strokeThickness?: number;\n    };\n\n    if (typeof oldStyle.dropShadow === 'boolean' && oldStyle.dropShadow)\n    {\n        const defaults = TextStyle.defaultDropShadow;\n\n        style.dropShadow = {\n            alpha: oldStyle.dropShadowAlpha ?? defaults.alpha,\n            angle: oldStyle.dropShadowAngle ?? defaults.angle,\n            blur: oldStyle.dropShadowBlur ?? defaults.blur,\n            color: oldStyle.dropShadowColor ?? defaults.color,\n            distance:   oldStyle.dropShadowDistance ?? defaults.distance,\n        };\n    }\n\n    if (oldStyle.strokeThickness !== undefined)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'strokeThickness is now a part of stroke');\n        // #endif\n\n        const color = oldStyle.stroke;\n        let obj: FillStyle = {};\n\n        // handles stroke: 0x0, stroke: { r: 0, g: 0, b: 0, a: 0 } stroke: new Color(0x0)\n        if (Color.isColorLike(color as ColorSource))\n        {\n            obj.color = color as ColorSource;\n        }\n        // handles stroke: new FillGradient()\n        else if (color instanceof FillGradient || color instanceof FillPattern)\n        {\n            obj.fill = color as FillGradient | FillPattern;\n        }\n        // handles stroke: { color: 0x0 } or stroke: { fill: new FillGradient() }\n        else if (Object.hasOwnProperty.call(color, 'color') || Object.hasOwnProperty.call(color, 'fill'))\n        {\n            obj = color as FillStyle;\n        }\n        else\n        {\n            throw new Error('Invalid stroke value.');\n        }\n\n        style.stroke = {\n            ...obj,\n            width: oldStyle.strokeThickness\n        };\n    }\n\n    if (Array.isArray(oldStyle.fillGradientStops))\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'gradient fill is now a fill pattern: `new FillGradient(...)`');\n        // #endif\n\n        let fontSize: number;\n\n        // eslint-disable-next-line no-eq-null, eqeqeq\n        if (style.fontSize == null)\n        {\n            style.fontSize = TextStyle.defaultTextStyle.fontSize;\n        }\n        else if (typeof style.fontSize === 'string')\n        {\n            // eg '34px' to number\n            fontSize = parseInt(style.fontSize as string, 10);\n        }\n        else\n        {\n            fontSize = style.fontSize as number;\n        }\n\n        const gradientFill = new FillGradient({\n            start: { x: 0, y: 0 },\n            end: { x: 0, y: (fontSize || 0) * 1.7 },\n        });\n\n        const fills: number[] = oldStyle.fillGradientStops\n            .map((color: ColorSource) => Color.shared.setValue(color).toNumber());\n\n        fills.forEach((number, index) =>\n        {\n            const ratio = index / (fills.length - 1);\n\n            gradientFill.addColorStop(ratio, number);\n        });\n\n        style.fill = {\n            fill: gradientFill\n        };\n    }\n}\n\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../../sprite/BatchableSprite';\nimport { updateTextBounds } from '../utils/updateTextBounds';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../../container/Container';\nimport type { Text } from '../Text';\n\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n        this._renderer.renderableGC.addManagedHash(this, '_gpuText');\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as Text;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text._getKey();\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(text);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (text._didTextUpdate)\n        {\n            this._updateText(text);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(text: Text)\n    {\n        text.off('destroyed', this._destroyRenderableBound);\n\n        this._destroyRenderableById(text.uid);\n    }\n\n    private _destroyRenderableById(textUid: number)\n    {\n        const gpuText = this._gpuText[textUid];\n\n        this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[textUid] = null;\n    }\n\n    private _updateText(text: Text)\n    {\n        const newKey = text._getKey();\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(text);\n        }\n\n        text._didTextUpdate = false;\n\n        updateTextBounds(batchableSprite, text);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const gpuText = this._getGpuText(text);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);\n        }\n\n        gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);\n        gpuText.currentKey = text._getKey();\n        batchableSprite.texture = gpuText.texture;\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return this._gpuText[text.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const gpuTextData: CanvasTextPipe['_gpuText'][number] = {\n            texture: null,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n        };\n\n        gpuTextData.batchableSprite.renderable = text;\n        gpuTextData.batchableSprite.transform = text.groupTransform;\n        gpuTextData.batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        gpuTextData.batchableSprite.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        this._gpuText[text.uid] = gpuTextData;\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        this._updateText(text);\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        text.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n","import { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/**\n * Measuring the bounds of a canvas' visible (non-transparent) pixels.\n * @param canvas - The canvas to measure.\n * @param resolution - The resolution of the canvas.\n * @returns The bounding box of the canvas' visible pixels.\n * @since 7.1.0\n * @memberof utils\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution = 1): Rectangle\n{\n    // https://gist.github.com/timdown/021d9c8f2aabc7092df564996f5afbbf\n\n    const { width, height } = canvas;\n\n    const context = canvas.getContext('2d', {\n        willReadFrequently: true,\n    });\n\n    if (context === null)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    return new Rectangle(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n}\n","import { Color } from '../../../color/Color';\nimport { ExtensionType } from '../../../extensions/Extensions';\nimport { nextPow2 } from '../../../maths/misc/pow2';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { TextOptions } from '../AbstractText';\nimport type { Text } from '../Text';\n\ninterface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @memberof rendering\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private _activeTextures: Record<string, {\n        canvasAndContext: CanvasAndContext,\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    public getTextureSize(text: string, resolution: number, style: TextStyle): { width: number, height: number }\n    {\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        let width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        let height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        width = Math.ceil((width) - 1e-6);\n        height = Math.ceil((height) - 1e-6);\n        width = nextPow2(width);\n        height = nextPow2(height);\n\n        return { width, height };\n    }\n\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    public getTexture(options: TextOptions): Texture;\n    public getTexture(options: TextOptions | string, resolution?: number, style?: TextStyle, _textKey?: string): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style,\n                resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(\n            options as {text: string, style: TextStyle, resolution?: number}\n        );\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    public createTextureAndCanvas(options: {text: string, style: TextStyle, resolution?: number})\n    {\n        const { text, style } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        // create a texture from the canvas\n        const { canvas } = canvasAndContext;\n\n        this.renderTextToCanvas(text, style, resolution, canvasAndContext);\n\n        const texture = getPo2TextureFromSource(canvas, width, height, resolution);\n\n        if (style.trim)\n        {\n            const trimmed = getCanvasBoundingBox(canvas, resolution);\n\n            texture.frame.copyFrom(trimmed);\n\n            texture.updateUvs();\n        }\n\n        return { texture, canvasAndContext };\n    }\n\n    public getManagedTexture(text: Text)\n    {\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        const textKey = text._getKey();\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const { texture, canvasAndContext } = this.createTextureAndCanvas(text);\n\n        this._activeTextures[textKey] = {\n            canvasAndContext,\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Returns a texture that was created wit the above `getTexture` function.\n     * Handy if you are done with a texture and want to return it to the pool.\n     * @param texture - The texture to be returned.\n     */\n    public returnTexture(texture: Texture)\n    {\n        const source = texture.source;\n\n        source.resource = null;\n        source.uploadMethodId = 'unknown';\n        source.alphaMode = 'no-premultiply-alpha';\n\n        TexturePool.returnTexture(texture);\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext);\n\n            this.returnTexture(activeTexture.texture);\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     *\n     * By default this is used internally to ensure the texture is correct before rendering,\n     * but it can be used called externally, for example from this class to 'pre-generate' the texture from a piece of text,\n     * and then shared across multiple Sprites.\n     * @param text\n     * @param style\n     * @param resolution\n     * @param canvasAndContext\n     */\n    public renderTextToCanvas(text: string, style: TextStyle, resolution: number, canvasAndContext: CanvasAndContext): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.textBaseline = style.textBaseline;\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (style.padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context, measured) : null;\n\n                if (style._stroke?.width)\n                {\n                    const padding = style._stroke.width * style._stroke.alignment;\n\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context, measured, padding);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + style.padding,\n                        linePositionY + style.padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param text - The text to draw\n     * @param style\n     * @param canvasAndContext\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n","export const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n             \n            }\n        `,\n    }\n\n};\n\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);  \n              \n                return coverage;\n            }\n        `,\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\nexport class SdfShader extends Shader\n{\n    constructor()\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const maxTextures = getMaxTexturesPerBatch();\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @memberof text */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @memberof text\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @memberof text\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @memberof text\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    public applyFillAsTint = true;\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            // texture may not exist if the char is \" \", \\n, \\r, or \\t.\n            this.chars[i].texture?.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\n\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { TextStyle } from '../text/TextStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n    textureSize?: number\n    mipmap?: boolean\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @memberof text\n * @ignore\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    public static defaultOptions: DynamicBitmapFontOptions = {\n        textureSize: 512,\n        style: new TextStyle(),\n        mipmap: true,\n    };\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 0;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n    private readonly _textureSize: number;\n    private readonly _mipmap: boolean;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = { ...DynamicBitmapFont.defaultOptions, ...options };\n\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = resolveCharacters(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        let maxCharHeight = 0;\n        let skipTexture = false;\n\n        const maxTextureWidth = canvas.width / this.resolution;\n        const maxTextureHeight = canvas.height / this.resolution;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps height\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = metrics.width * fontScale;\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = textureGlyphWidth + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight));// / 1.5;\n            }\n\n            if (currentX + paddedWidth > maxTextureWidth)\n            {\n                currentY += maxCharHeight;\n\n                // reset the line x and height..\n                maxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + maxCharHeight > maxTextureHeight)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentY = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n\n            // now add it to the font data..\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n            this._textureSize,\n            this._textureSize,\n            textureResolution\n        );\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload',\n                autoGenerateMipmaps: this._mipmap,\n            }),\n\n        });\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        if (style.stroke && strokeThickness)\n        {\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (style._fill)\n        {\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\nexport function getBitmapTextLayout(\n    chars: string[],\n    style: TextStyle,\n    font: AbstractBitmapFont<any>,\n    trimEnd: boolean\n): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n\n        if (trimEnd)\n        {\n            let lastChar = currentLine.chars[index];\n\n            while (lastChar === ' ')\n            {\n                currentLine.width -= font.chars[lastChar].xAdvance;\n                lastChar = currentLine.chars[--index];\n            }\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord\n                && style.wordWrap\n                && (currentLine.width + currentWord.width - adjustedLetterSpacing) > adjustedWordWrapWidth;\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\nlet fontCount = 0;\n\n/**\n *\n * The options for installing a new BitmapFont. Once installed the font will be available for use in the BitmapText.\n * It can be accessed by the `fontFamily` property of the TextStyle.\n *\n * Install a new BitmapFont will create the characters provided for the font and store them in the cache.\n * But don't worry, if a character is requested that hasn't been generated yet, it will be created on the fly.\n * @memberof text\n */\nexport interface BitmapFontInstallOptions\n{\n    /** the name of the font, this will be the name you use in the fontFamily of text style to access this font */\n    name?: string;\n    /**\n     * Characters included in the font set. You can also use ranges.\n     * For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     */\n    chars?: string | (string | string[])[];\n    /**\n     * Render resolution for glyphs.\n     * @default 1\n     */\n    resolution?: number;\n    /**\n     * Padding between glyphs on texture atlas. Lower values could mean more visual artifacts\n     * and bleeding from other glyphs, larger values increase the space required on the texture.\n     * @default 4\n     */\n    padding?: number;\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * If true, this could potentially increase the performance, but may impact the rendered text appearance.\n     * @default false\n     */\n    skipKerning?: boolean;\n    /** Style options to render with BitmapFont. */\n    style?: TextStyle | TextStyleOptions;\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @memberof text\n * @name BitmapFontManager\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill && !style._stroke)\n        {\n            fontFamilyKey += style._fill.fill.styleKey;\n            overrideFill = false;\n        }\n        else if (style._stroke || style.dropShadow)\n        {\n            // if there is a stoke, we need to use the style key as this the font generated cannot be tinted\n            // due to the fact the font has at least two colors.\n            let key = style.styleKey;\n\n            // remove the font size..\n            key = key.substring(0, key.lastIndexOf('-'));\n\n            fontFamilyKey = `${key}-bitmap`;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fontCount++;\n\n            // warn users if they have created too many dynamic fonts\n            if (fontCount > 50)\n            {\n                // eslint-disable-next-line max-len\n                warn('BitmapText', `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n            }\n\n            fnt.once('destroy', () =>\n            {\n                fontCount--;\n                Cache.remove(fontFamilyKey);\n            });\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public getLayout(text: string, style: TextStyle, trimEnd: boolean = true): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        return getBitmapTextLayout([...text], style, bitmapFont, trimEnd);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public measureText(\n        text: string,\n        style: TextStyle,\n        trimEnd: boolean = true\n    ): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style, trimEnd);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            font.destroy();\n        }\n    }\n}\n\nexport const BitmapFontManager = new BitmapFontManagerClass();\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { BitmapText } from './BitmapText';\n\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuBitmapText: Record<number, Graphics> = {};\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBitmapText');\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public destroyRenderable(bitmapText: BitmapText)\n    {\n        bitmapText.off('destroyed', this._destroyRenderableBound);\n\n        this._destroyRenderableByUid(bitmapText.uid);\n    }\n\n    private _destroyRenderableByUid(renderableUid: number)\n    {\n        const context = this._gpuBitmapText[renderableUid].context;\n\n        if (context.customShader)\n        {\n            BigPool.return(context.customShader as PoolItem);\n\n            context.customShader = null;\n        }\n\n        BigPool.return(this._gpuBitmapText[renderableUid] as PoolItem);\n        this._gpuBitmapText[renderableUid] = null;\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                context.customShader = BigPool.get(SdfShader);\n            }\n        }\n\n        const chars = Array.from(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        let index = 0;\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = chars[index++];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = BigPool.get(Graphics);\n\n        this._gpuBitmapText[bitmapText.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        bitmapText.on('destroyed', this._destroyRenderableBound);\n\n        return this._gpuBitmapText[bitmapText.uid];\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        for (const uid in this._gpuBitmapText)\n        {\n            this._destroyRenderableByUid(uid as unknown as number);\n        }\n\n        this._gpuBitmapText = null;\n\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedFillStyle, ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { HTMLTextStyle } from '../../text-html/HTMLTextStyle';\nimport type { TextStyle } from '../TextStyle';\n\nconst valuesToIterateForKeys: Partial<keyof TextStyle | keyof HTMLTextStyle>[] = [\n    'align',\n    'breakWords',\n    'cssOverrides',\n    'fontVariant',\n    'fontWeight',\n    'leading',\n    'letterSpacing',\n    'lineHeight',\n    'padding',\n    'textBaseline',\n    'trim',\n    'whiteSpace',\n    'wordWrap',\n    'wordWrapWidth',\n    'fontFamily',\n    'fontStyle',\n    'fontSize',\n] as const;\n\n/**\n * Generates a unique key for the text style.\n * @param style - The style to generate a key for.\n * @returns the key for the style.\n */\nexport function generateTextStyleKey(style: TextStyle): string\n{\n    const key = [];\n\n    let index = 0;\n\n    for (let i = 0; i < valuesToIterateForKeys.length; i++)\n    {\n        const prop = `_${valuesToIterateForKeys[i]}`;\n\n        key[index++] = style[prop as keyof typeof style];\n    }\n\n    index = addFillStyleKey(style._fill, key as string[], index);\n    index = addStokeStyleKey(style._stroke, key as string[], index);\n    index = addDropShadowKey(style.dropShadow, key as string[], index);\n\n    return key.join('-');\n}\n\nfunction addFillStyleKey(fillStyle: ConvertedFillStyle, key: (number | string)[], index: number)\n{\n    if (!fillStyle) return index;\n\n    key[index++] = fillStyle.color;\n    key[index++] = fillStyle.alpha;\n    key[index++] = fillStyle.fill?.styleKey;\n\n    return index;\n}\n\nfunction addStokeStyleKey(strokeStyle: ConvertedStrokeStyle, key: (number | string)[], index: number)\n{\n    if (!strokeStyle) return index;\n\n    index = addFillStyleKey(strokeStyle, key, index);\n\n    key[index++] = strokeStyle.width;\n    key[index++] = strokeStyle.alignment;\n    key[index++] = strokeStyle.cap;\n    key[index++] = strokeStyle.join;\n    key[index++] = strokeStyle.miterLimit;\n\n    return index;\n}\n\nfunction addDropShadowKey(dropShadow: TextStyle['dropShadow'], key: (number | string)[], index: number)\n{\n    if (!dropShadow) return index;\n\n    key[index++] = dropShadow.alpha;\n    key[index++] = dropShadow.angle;\n    key[index++] = dropShadow.blur;\n    key[index++] = dropShadow.distance;\n    key[index++] = Color.shared.setValue(dropShadow.color).toNumber();\n\n    return index;\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Container } from '../../container/Container';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\ninterface MeshData\n{\n    batched: boolean;\n    indexSize: number;\n    vertexSize: number;\n}\n\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _meshDataHash: Record<number, MeshData> = Object.create(null);\n    private _gpuBatchableMeshHash: Record<number, BatchableMesh> = Object.create(null);\n    private _adaptor: MeshAdaptor;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n\n        renderer.renderableGC.addManagedHash(this, '_gpuBatchableMeshHash');\n        renderer.renderableGC.addManagedHash(this, '_meshDataHash');\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            if (batchableMesh.texture.uid !== mesh._texture.uid)\n            {\n                batchableMesh._textureMatrixUpdateId = -1;\n            }\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh._texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public destroyRenderable(mesh: Mesh)\n    {\n        this._meshDataHash[mesh.uid] = null;\n\n        const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];\n\n        if (gpuMesh)\n        {\n            BigPool.return(gpuMesh as PoolItem);\n            this._gpuBatchableMeshHash[mesh.uid] = null;\n        }\n\n        mesh.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        this._meshDataHash[mesh.uid] = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        mesh.on('destroyed', this._destroyRenderableBound);\n\n        return this._meshDataHash[mesh.uid];\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = BigPool.get(BatchableMesh);\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuBatchableMeshHash)\n        {\n            if (this._gpuBatchableMeshHash[i])\n            {\n                BigPool.return(this._gpuBatchableMeshHash[i] as PoolItem);\n            }\n        }\n\n        this._gpuBatchableMeshHash = null;\n        this._meshDataHash = null;\n\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link scene.PlaneGeometry}\n * @memberof scene\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @memberof scene\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { type PointData } from '../../maths/point/PointData';\nimport { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @memberof scene\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n\n    /** The anchor point of the NineSliceSprite. */\n    anchor?: PointData\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @memberof scene\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    public _leftWidth: number;\n    public _rightWidth: number;\n    public _topHeight: number;\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private _anchorX: any;\n    private _anchorY: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this._anchorX = options.anchor?.x;\n        this._anchorY = options.anchor?.y;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const p = this.positions;\n        const {\n            width,\n            height,\n            _leftWidth,\n            _rightWidth,\n            _topHeight,\n            _bottomHeight,\n            _anchorX,\n            _anchorY,\n        } = this;\n\n        const w = _leftWidth + _rightWidth;\n        const scaleW = width > w ? 1.0 : width / w;\n\n        const h = _topHeight + _bottomHeight;\n        const scaleH = height > h ? 1.0 : height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        const anchorOffsetX = _anchorX * width;\n        const anchorOffsetY = _anchorY * height;\n\n        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n        p[2] = p[10] = p[18] = p[26] = (_leftWidth * scale) - anchorOffsetX;\n        p[4] = p[12] = p[20] = p[28] = width - (_rightWidth * scale) - anchorOffsetX;\n        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n\n        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n        p[9] = p[11] = p[13] = p[15] = (_topHeight * scale) - anchorOffsetY;\n        p[17] = p[19] = p[21] = p[23] = height - (_bottomHeight * scale) - anchorOffsetY;\n        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private readonly _gpuSpriteHash: Record<number, BatchableMesh> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuSpriteHash');\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture\n        );\n    }\n\n    public destroyRenderable(sprite: NineSliceSprite)\n    {\n        const batchableMesh = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableMesh.geometry as PoolItem);\n        BigPool.return(batchableMesh as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n\n        sprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.setTexture(sprite._texture);\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): BatchableMesh\n    {\n        const batchableMesh = BigPool.get(BatchableMesh);\n\n        batchableMesh.geometry = BigPool.get(NineSliceGeometry);\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableMesh;\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', this._destroyRenderableBound);\n\n        return batchableMesh;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            const batchableMesh = this._gpuSpriteHash[i];\n\n            batchableMesh.geometry.destroy();\n        }\n\n        (this._gpuSpriteHash as null) = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { Point } from '../maths/point/Point';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\ntype FilterAction = 'pushFilter' | 'popFilter';\n\n//\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: FilterAction,\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\nexport interface FilterData\n{\n    skip: boolean;\n    enabledLength?: number;\n    inputTexture: Texture\n    bounds: Bounds,\n    blendRequired: boolean,\n    container: Container,\n    filterEffect: FilterEffect,\n    previousRenderSurface: RenderSurface,\n    backTexture?: Texture,\n}\n\n/**\n * System that manages the filter pipeline\n * @memberof rendering\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        if (!this._filterStack[this._filterStackIndex])\n        {\n            this._filterStack[this._filterStackIndex] = this._getFilterData();\n        }\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        this._filterStackIndex++;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds: Bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? colorTextureSource._resolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= colorTextureSource.antialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            const viewPort = renderer.renderTarget.rootViewPort;\n\n            const rootResolution = renderer.renderTarget.renderTarget.resolution;\n\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad(padding | 0);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set all the filter data\n        filterData.skip = false;\n\n        filterData.bounds = bounds;\n        filterData.blendRequired = blendRequired;\n        filterData.container = instruction.container;\n        filterData.filterEffect = instruction.filterEffect;\n\n        filterData.previousRenderSurface = renderer.renderTarget.renderSurface;\n\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            resolution,\n            antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        this._filterStackIndex--;\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        this._activeFilterData = filterData;\n\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        let backTexture = Texture.EMPTY;\n\n        renderer.renderTarget.finishRenderPass();\n\n        if (filterData.blendRequired)\n        {\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const previousBounds = this._filterStackIndex > 0 ? this._filterStack[this._filterStackIndex - 1].bounds : null;\n\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);\n\n            backTexture = this.getBackTexture(renderTarget, bounds, previousBounds);\n        }\n\n        filterData.backTexture = backTexture;\n\n        const filters = filterData.filterEffect.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(backTexture.source, 3);\n\n        renderer.globalUniforms.pop();\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            // this.applyFilter(filters[0], inputTexture, filterData.previousRenderSurface, false);\n            filters[0].apply(this, inputTexture, filterData.previousRenderSurface, false);\n\n            // return the texture to the pool so we can reuse the next frame\n            TexturePool.returnTexture(inputTexture);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            // get another texture that we will render the next filter too\n            let flop = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.previousRenderSurface, false);\n\n            // return those textures for later!\n            TexturePool.returnTexture(flip);\n            TexturePool.returnTexture(flop);\n        }\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(backTexture);\n        }\n    }\n\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._filterStack[this._filterStackIndex];\n\n        const bounds = filterData.bounds;\n\n        const offset = Point.shared;\n        const previousRenderSurface = filterData.previousRenderSurface;\n\n        const isFinalTarget = previousRenderSurface === output;\n\n        let resolution = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n\n        // to find the previous resolution we need to account for the skipped filters\n        // the following will find the last non skipped filter...\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        if (currentIndex > 0)\n        {\n            resolution = this._filterStack[currentIndex].inputTexture.source._resolution;\n        }\n\n        const filterUniforms = this._filterGlobalUniforms;\n        const uniforms = filterUniforms.uniforms;\n\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            let lastIndex = this._filterStackIndex;\n\n            // get previous bounds.. we must take into account skipped filters also..\n            while (lastIndex > 0)\n            {\n                lastIndex--;\n                const filterData = this._filterStack[this._filterStackIndex - 1];\n\n                if (!filterData.skip)\n                {\n                    offset.x = filterData.bounds.minX;\n                    offset.y = filterData.bounds.minY;\n\n                    break;\n                }\n            }\n\n            outputFrame[0] = bounds.minX - offset.x;\n            outputFrame[1] = bounds.minY - offset.y;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offset.x * resolution;\n        globalFrame[1] = offset.y * resolution;\n\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // set the output texture - this is where we are going to render to\n\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n        filterUniforms.update();\n\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(filterUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(filterUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    private _getFilterData(): FilterData\n    {\n        return {\n            skip: false,\n            inputTexture: null,\n            bounds: new Bounds(),\n            container: null,\n            filterEffect: null,\n            blendRequired: false,\n            previousRenderSurface: null,\n        };\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy?: () => void;\n}\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n","/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer ||= new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer ||= new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n      \n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @property {number} size - The size of the particle buffer.\n * @property {Record<string, ParticleRendererProperty>} properties - A record of attributes that the particle container uses.\n */\nexport interface ParticleBufferOptions\n{\n    size: number;\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../../container/Container';\nimport type { ParticleContainer } from './ParticleContainer';\n\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @memberof scene\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    public adaptor: ParticleContainerAdaptor;\n    public readonly state = State.for2d();\n    public readonly renderer: Renderer;\n\n    private _gpuBufferHash: Record<number, ParticleBuffer> = Object.create(null);\n    // eslint-disable-next-line max-len\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as unknown as (renderable: Container) => void;\n\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return this._gpuBufferHash[renderable.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        this._gpuBufferHash[renderable.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        renderable.on('destroyed', this._destroyRenderableBound);\n\n        return this._gpuBufferHash[renderable.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n\n    }\n\n    public destroyRenderable(renderable: ParticleContainer)\n    {\n        const buffer = this._gpuBufferHash[renderable.uid];\n\n        buffer.destroy();\n\n        this._gpuBufferHash[renderable.uid] = null;\n\n        renderable.off('destroyed', this._destroyRenderableBound);\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n","import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPipe.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPipe.state;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../../utils/logging/warn';\nimport { FillGradient } from '../../../graphics/shared/fill/FillGradient';\nimport { FillPattern } from '../../../graphics/shared/fill/FillPattern';\n\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { ConvertedFillStyle } from '../../../graphics/shared/FillTypes';\nimport type { CanvasTextMetrics } from '../CanvasTextMetrics';\n\n// 5 decimal places\nconst PRECISION = 100000;\n\n/**\n * Converts a PixiJS fill style into a Canvas-compatible fill style.\n * Handles solid colors, textures, patterns, and gradients.\n * @param fillStyle - The PixiJS fill style to convert\n * @param context - The canvas rendering context\n * @param textMetrics - Metrics about the text being rendered\n * @param padding - Padding to add to the text metrics (used to ensure that the gradient accommodates the stroke width)\n * @returns Canvas-compatible fill style (string, CanvasGradient, or CanvasPattern)\n */\nexport function getCanvasFillStyle(\n    fillStyle: ConvertedFillStyle,\n    context: ICanvasRenderingContext2D,\n    textMetrics?: CanvasTextMetrics,\n    padding = 0\n): string | CanvasGradient | CanvasPattern\n{\n    // Solid color fill\n    if (fillStyle.texture === Texture.WHITE && !fillStyle.fill)\n    {\n        return Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();\n    }\n    // Basic texture fill\n    else if (!fillStyle.fill)\n    {\n        const pattern = context.createPattern(fillStyle.texture.source.resource, 'repeat');\n        const tempMatrix = fillStyle.matrix.copyTo(Matrix.shared);\n\n        tempMatrix.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height);\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    // Pattern fill\n    else if (fillStyle.fill instanceof FillPattern)\n    {\n        const fillPattern = fillStyle.fill;\n        const pattern = context.createPattern(fillPattern.texture.source.resource, 'repeat');\n        const tempMatrix = fillPattern.transform.copyTo(Matrix.shared);\n\n        tempMatrix.scale(\n            fillPattern.texture.frame.width,\n            fillPattern.texture.frame.height\n        );\n\n        pattern.setTransform(tempMatrix);\n\n        return pattern;\n    }\n    // Gradient fill\n    else if (fillStyle.fill instanceof FillGradient)\n    {\n        const fillGradient = fillStyle.fill;\n\n        const isLinear = fillGradient.type === 'linear';\n        const isLocal = fillGradient.textureSpace === 'local';\n\n        let width = 1;\n        let height = 1;\n\n        // Use text dimensions if in local space\n        if (isLocal && textMetrics)\n        {\n            width = textMetrics.width + padding;\n            height = textMetrics.height + padding;\n        }\n\n        let gradient: CanvasGradient;\n        let isNearlyVertical = false;\n\n        if (isLinear)\n        {\n            const { start, end } = fillGradient;\n\n            gradient = context.createLinearGradient(\n                start.x * width,\n                start.y * height,\n                end.x * width,\n                end.y * height\n            );\n\n            // Check if gradient is nearly vertical (10% threshold)\n            isNearlyVertical = Math.abs(end.x - start.x) < Math.abs((end.y - start.y) * 0.1);\n        }\n        else\n        {\n            const { center, innerRadius, outerCenter, outerRadius } = fillGradient;\n\n            gradient = context.createRadialGradient(\n                center.x * width,\n                center.y * height,\n                innerRadius * width,\n                outerCenter.x * width,\n                outerCenter.y * height,\n                outerRadius * width\n            );\n        }\n\n        // For vertical gradients in local space, repeat gradient per text line\n        if (isNearlyVertical && isLocal && textMetrics)\n        {\n            const ratio = (textMetrics.lineHeight) / height;\n\n            for (let i = 0; i < textMetrics.lines.length; i++)\n            {\n                const start = ((i * textMetrics.lineHeight) + (padding / 2)) / height;\n\n                fillGradient.colorStops.forEach((stop) =>\n                {\n                    // Convert to global space\n                    const globalStop = start + (stop.offset * ratio);\n\n                    gradient.addColorStop(\n                        // fix to 5 decimal places to avoid floating point precision issues\n                        Math.floor(globalStop * PRECISION) / PRECISION,\n                        Color.shared.setValue(stop.color).toHex()\n                    );\n                });\n            }\n        }\n        else\n        {\n            // Standard global space gradient handling\n            fillGradient.colorStops.forEach((stop) =>\n            {\n                gradient.addColorStop(stop.offset, Color.shared.setValue(stop.color).toHex());\n            });\n        }\n\n        return gradient;\n    }\n\n    // #if _DEBUG\n    warn('FillStyle not recognised', fillStyle);\n    // #endif\n\n    return 'red';\n}\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { type BatchableSprite } from '../../sprite/BatchableSprite';\nimport { type AbstractText } from '../AbstractText';\n\n/**\n * Updates the bounds of the given batchable sprite based on the provided text object.\n *\n * This function adjusts the bounds of the batchable sprite to match the dimensions\n * and anchor point of the text's texture. Additionally, it compensates for any padding\n * specified in the text's style to ensure the text is rendered correctly on screen.\n * @param {BatchableSprite} batchableSprite - The sprite whose bounds need to be updated.\n * @param {AbstractText} text - The text object containing the texture and style information.\n */\nexport function updateTextBounds(batchableSprite: BatchableSprite, text: AbstractText)\n{\n    const { texture, bounds } = batchableSprite;\n\n    updateQuadBounds(bounds, text._anchor, texture);\n\n    const padding = text._style.padding;\n    // When HTML text textures are created, they include the padding around the text content\n    // to prevent text clipping and provide a buffer zone. This padding is built into\n    // the texture itself. However, we don't want this padding to affect the text's\n    // actual position on screen.\n    // To compensate, we shift the render position back by the padding amount,\n    // ensuring the text appears exactly where intended while maintaining the\n    // buffer zone around it.\n\n    bounds.minX -= padding;\n    bounds.minY -= padding;\n    bounds.maxX -= padding;\n    bounds.maxY -= padding;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../environment/canvas/ICanvasRenderingContext2D';\nimport type { TextStyle, TextStyleWhiteSpace } from '../TextStyle';\n\n// The type for Intl.Segmenter is only available since TypeScript 4.7.2, so let's make a polyfill for it.\ninterface ISegmentData\n{\n    segment: string;\n}\ninterface ISegments\n{\n    [Symbol.iterator](): IterableIterator<ISegmentData>;\n}\ninterface ISegmenter\n{\n    segment(input: string): ISegments;\n}\ninterface IIntl\n{\n    Segmenter?: {\n        prototype: ISegmenter;\n        new(): ISegmenter;\n    };\n}\n\n/**\n * A number, or a string containing a number.\n * @memberof text\n * @typedef {object} FontMetrics\n * @property {number} ascent - Font ascent\n * @property {number} descent - Font descent\n * @property {number} fontSize - Font size\n */\nexport interface FontMetrics\n{\n    ascent: number;\n    descent: number;\n    fontSize: number;\n}\n\ntype CharacterWidthCache = Record<string, number>;\n\n// Default settings used for all getContext calls\nconst contextSettings: ICanvasRenderingContext2DSettings = {\n    // TextMetrics requires getImageData readback for measuring fonts.\n    willReadFrequently: true,\n};\n\n/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n * @example\n * import { CanvasTextMetrics, TextStyle } from 'pixi.js';\n *\n * const style = new TextStyle({\n *     fontFamily: 'Arial',\n *     fontSize: 24,\n *     fill: 0xff1010,\n *     align: 'center',\n * });\n * const textMetrics = CanvasTextMetrics.measureText('Your text', style);\n * @memberof text\n */\nexport class CanvasTextMetrics\n{\n    /** The text that was measured. */\n    public text: string;\n\n    /** The style that was measured. */\n    public style: TextStyle;\n\n    /** The measured width of the text. */\n    public width: number;\n\n    /** The measured height of the text. */\n    public height: number;\n\n    /** An array of lines of the text broken by new lines and wrapping is specified in style. */\n    public lines: string[];\n\n    /** An array of the line widths for each line matched to `lines`. */\n    public lineWidths: number[];\n\n    /** The measured line height for this style. */\n    public lineHeight: number;\n\n    /** The maximum line width for all measured lines. */\n    public maxLineWidth: number;\n\n    /** The font properties object from TextMetrics.measureFont. */\n    public fontProperties: FontMetrics;\n\n    /**\n     * String used for calculate font metrics.\n     * These characters are all tall to help calculate the height required for text.\n     */\n    public static METRICS_STRING = '|q';\n\n    /** Baseline symbol for calculate font metrics. */\n    public static BASELINE_SYMBOL = 'M';\n\n    /** Baseline multiplier for calculate font metrics. */\n    public static BASELINE_MULTIPLIER = 1.4;\n\n    /** Height multiplier for setting height of canvas to calculate font metrics. */\n    public static HEIGHT_MULTIPLIER = 2.0;\n\n    /**\n     * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n     * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n     * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n     * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n     * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n     * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n     * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n     * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n     * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n     */\n    public static graphemeSegmenter: (s: string) => string[] = (() =>\n    {\n        if (typeof (Intl as IIntl)?.Segmenter === 'function')\n        {\n            const segmenter = new (Intl as IIntl).Segmenter();\n\n            return (s: string) => [...segmenter.segment(s)].map((x) => x.segment);\n        }\n\n        return (s: string) => [...s];\n    })();\n\n    public static _experimentalLetterSpacingSupported?: boolean;\n\n    /**\n     * Checking that we can use modern canvas 2D API.\n     *\n     * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n     * @see TextMetrics.experimentalLetterSpacing\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n     * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n     */\n    public static get experimentalLetterSpacingSupported(): boolean\n    {\n        let result = CanvasTextMetrics._experimentalLetterSpacingSupported;\n\n        if (result !== undefined)\n        {\n            const proto = DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n\n            result\n                = CanvasTextMetrics._experimentalLetterSpacingSupported\n                = 'letterSpacing' in proto || 'textLetterSpacing' in proto;\n        }\n\n        return result;\n    }\n\n    /**\n     * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n     * lead to more accurate letter-spacing results because it does not try to manually draw\n     * each character. However, this Chrome API is experimental and may not serve all cases yet.\n     * @see TextMetrics.experimentalLetterSpacingSupported\n     */\n    public static experimentalLetterSpacing = false;\n\n    /** Cache of {@see TextMetrics.FontMetrics} objects. */\n    private static _fonts: Record<string, FontMetrics> = {};\n\n    /** Cache of new line chars. */\n    private static readonly _newlines: number[] = [\n        0x000A, // line feed\n        0x000D, // carriage return\n    ];\n\n    /** Cache of breaking spaces. */\n    private static readonly _breakingSpaces: number[] = [\n        0x0009, // character tabulation\n        0x0020, // space\n        0x2000, // en quad\n        0x2001, // em quad\n        0x2002, // en space\n        0x2003, // em space\n        0x2004, // three-per-em space\n        0x2005, // four-per-em space\n        0x2006, // six-per-em space\n        0x2008, // punctuation space\n        0x2009, // thin space\n        0x200A, // hair space\n        0x205F, // medium mathematical space\n        0x3000, // ideographic space\n    ];\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __canvas: ICanvas;\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static __context: ICanvasRenderingContext2D;\n\n    private static readonly _measurementCache: Record<string, CanvasTextMetrics> = {};\n\n    /**\n     * @param text - the text that was measured\n     * @param style - the style that was measured\n     * @param width - the measured width of the text\n     * @param height - the measured height of the text\n     * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param lineWidths - an array of the line widths for each line matched to `lines`\n     * @param lineHeight - the measured line height for this style\n     * @param maxLineWidth - the maximum line width for all measured lines\n     * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text: string, style: TextStyle, width: number, height: number, lines: string[], lineWidths: number[],\n        lineHeight: number, maxLineWidth: number, fontProperties: FontMetrics)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     * @param text - The text to measure.\n     * @param style - The text style to use for measuring\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @param wordWrap\n     * @returns Measured width and height of the text.\n     */\n    public static measureText(\n        text = ' ',\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas,\n        wordWrap: boolean = style.wordWrap,\n    ): CanvasTextMetrics\n    {\n        const textKey = `${text}:${style.styleKey}`;\n\n        // TODO - if we find this starts to go nuts with memory, we can remove the cache\n        // or instead just stick a usage tick that we increment each time we return it.\n        // if some are not used, we can just tidy them up!\n        if (CanvasTextMetrics._measurementCache[textKey]) return CanvasTextMetrics._measurementCache[textKey];\n\n        const font = fontStringFromTextStyle(style);\n        const fontProperties = CanvasTextMetrics.measureFont(font);\n\n        // fallback in case UA disallow canvas data extraction\n        if (fontProperties.fontSize === 0)\n        {\n            fontProperties.fontSize = style.fontSize as number;\n            fontProperties.ascent = style.fontSize as number;\n        }\n\n        const context = CanvasTextMetrics.__context; // canvas.getContext('2d', contextSettings);\n\n        context.font = font;\n\n        const outputText = wordWrap ? CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array<number>(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n\n        const strokeWidth = style._stroke?.width || 0;\n\n        let width = maxLineWidth + strokeWidth;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadow.distance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize;\n\n        let height = Math.max(lineHeight, fontProperties.fontSize + (strokeWidth))\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadow.distance;\n        }\n\n        const measurements = new CanvasTextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n\n        // CanvasTextMetrics._measurementCache[textKey] = measurements;\n\n        return measurements;\n    }\n\n    private static _measureText(\n        text: string,\n        letterSpacing: number,\n        context: ICanvasRenderingContext2D\n    )\n    {\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        const metrics = context.measureText(text);\n        let metricWidth = metrics.width;\n        const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n        const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n        let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n\n        if (metricWidth > 0)\n        {\n            if (useExperimentalLetterSpacing)\n            {\n                metricWidth -= letterSpacing;\n                boundsWidth -= letterSpacing;\n            }\n            else\n            {\n                const val = (CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n\n                metricWidth += val;\n                boundsWidth += val;\n            }\n        }\n\n        // NOTE: this is a bit of a hack as metrics.width and the bounding box width do not measure the same thing\n        // We can't seem to exclusively use one or the other, so are taking the largest of the two\n        return Math.max(metricWidth, boundsWidth);\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     * @param text - String to apply word wrapping to\n     * @param style - the style to use when wrapping\n     * @param canvas - optional specification of the canvas to use for measuring.\n     * @returns New string with new lines applied where required\n     */\n    private static _wordWrap(\n        text: string,\n        style: TextStyle,\n        canvas: ICanvas = CanvasTextMetrics._canvas\n    ): string\n    {\n        const context = canvas.getContext('2d', contextSettings);\n\n        let width = 0;\n        let line = '';\n        let lines = '';\n\n        const cache: CharacterWidthCache = Object.create(null);\n        const { letterSpacing, whiteSpace } = style;\n\n        // How to handle whitespaces\n        const collapseSpaces = CanvasTextMetrics._collapseSpaces(whiteSpace);\n        const collapseNewlines = CanvasTextMetrics._collapseNewlines(whiteSpace);\n\n        // whether or not spaces may be added to the beginning of lines\n        let canPrependSpaces = !collapseSpaces;\n\n        // There is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra letterSpace\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n        // break text into words, spaces and newline chars\n        const tokens = CanvasTextMetrics._tokenize(text);\n\n        for (let i = 0; i < tokens.length; i++)\n        {\n            // get the word, space or newlineChar\n            let token = tokens[i];\n\n            // if word is a new line\n            if (CanvasTextMetrics._isNewline(token))\n            {\n                // keep the new line\n                if (!collapseNewlines)\n                {\n                    lines += CanvasTextMetrics._addLine(line);\n                    canPrependSpaces = !collapseSpaces;\n                    line = '';\n                    width = 0;\n                    continue;\n                }\n\n                // if we should collapse new lines\n                // we simply convert it into a space\n                token = ' ';\n            }\n\n            // if we should collapse repeated whitespaces\n            if (collapseSpaces)\n            {\n                // check both this and the last tokens for spaces\n                const currIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(token);\n                const lastIsBreakingSpace = CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n\n                if (currIsBreakingSpace && lastIsBreakingSpace)\n                {\n                    continue;\n                }\n            }\n\n            // get word width from cache if possible\n            const tokenWidth = CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n\n            // word is longer than desired bounds\n            if (tokenWidth > wordWrapWidth)\n            {\n                // if we are not already at the beginning of a line\n                if (line !== '')\n                {\n                    // start newlines for overflow words\n                    lines += CanvasTextMetrics._addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // break large word over multiple lines\n                if (CanvasTextMetrics.canBreakWords(token, style.breakWords))\n                {\n                    // break word into characters\n                    const characters = CanvasTextMetrics.wordWrapSplit(token);\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        let char = characters[j];\n                        let lastChar = char;\n\n                        let k = 1;\n\n                        // we are not at the end of the token\n                        while (characters[j + k])\n                        {\n                            const nextChar = characters[j + k];\n\n                            // should not split chars\n                            if (!CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                            {\n                                // combine chars & move forward one\n                                char += nextChar;\n                            }\n                            else\n                            {\n                                break;\n                            }\n\n                            lastChar = nextChar;\n                            k++;\n                        }\n\n                        j += k - 1;\n\n                        const characterWidth = CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += CanvasTextMetrics._addLine(line);\n                            canPrependSpaces = false;\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += char;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                    // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += CanvasTextMetrics._addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    const isLastToken = i === tokens.length - 1;\n\n                    // give it its own line if it's not the end\n                    lines += CanvasTextMetrics._addLine(token, !isLastToken);\n                    canPrependSpaces = false;\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit because of existing words\n                // start a new line\n                if (tokenWidth + width > wordWrapWidth)\n                {\n                    // if its a space we don't want it\n                    canPrependSpaces = false;\n\n                    // add a new line\n                    lines += CanvasTextMetrics._addLine(line);\n\n                    // start a new line\n                    line = '';\n                    width = 0;\n                }\n\n                // don't add spaces to the beginning of lines\n                if (line.length > 0 || !CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces)\n                {\n                    // add the word to the current line\n                    line += token;\n\n                    // update width counter\n                    width += tokenWidth;\n                }\n            }\n        }\n\n        lines += CanvasTextMetrics._addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     * Convenience function for logging each line added during the wordWrap method.\n     * @param line    - The line of text to add\n     * @param newLine - Add new line character to end\n     * @returns A formatted line\n     */\n    private static _addLine(line: string, newLine = true): string\n    {\n        line = CanvasTextMetrics._trimRight(line);\n\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     * @param key            - The key\n     * @param letterSpacing  - The letter spacing\n     * @param cache          - The cache\n     * @param context        - The canvas context\n     * @returns The from cache.\n     */\n    private static _getFromCache(key: string, letterSpacing: number, cache: CharacterWidthCache,\n        context: ICanvasRenderingContext2D): number\n    {\n        let width = cache[key];\n\n        if (typeof width !== 'number')\n        {\n            width = CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Determines whether we should collapse breaking spaces.\n     * @param whiteSpace - The TextStyle property whiteSpace\n     * @returns Should collapse\n     */\n    private static _collapseSpaces(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');\n    }\n\n    /**\n     * Determines whether we should collapse newLine chars.\n     * @param whiteSpace - The white space\n     * @returns should collapse\n     */\n    private static _collapseNewlines(whiteSpace: TextStyleWhiteSpace): boolean\n    {\n        return (whiteSpace === 'normal');\n    }\n\n    /**\n     * Trims breaking whitespaces from string.\n     * @param text - The text\n     * @returns Trimmed string\n     */\n    private static _trimRight(text: string): string\n    {\n        if (typeof text !== 'string')\n        {\n            return '';\n        }\n\n        for (let i = text.length - 1; i >= 0; i--)\n        {\n            const char = text[i];\n\n            if (!CanvasTextMetrics.isBreakingSpace(char))\n            {\n                break;\n            }\n\n            text = text.slice(0, -1);\n        }\n\n        return text;\n    }\n\n    /**\n     * Determines if char is a newline.\n     * @param char - The character\n     * @returns True if newline, False otherwise.\n     */\n    private static _isNewline(char: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Determines if char is a breaking whitespace.\n     *\n     * It allows one to determine whether char should be a breaking whitespace\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param char - The character\n     * @param [_nextChar] - The next character\n     * @returns True if whitespace, False otherwise.\n     */\n    public static isBreakingSpace(char: string, _nextChar?: string): boolean\n    {\n        if (typeof char !== 'string')\n        {\n            return false;\n        }\n\n        return CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n    }\n\n    /**\n     * Splits a string into words, breaking-spaces and newLine characters\n     * @param text - The text\n     * @returns A tokenized array\n     */\n    private static _tokenize(text: string): string[]\n    {\n        const tokens: string[] = [];\n        let token = '';\n\n        if (typeof text !== 'string')\n        {\n            return tokens;\n        }\n\n        for (let i = 0; i < text.length; i++)\n        {\n            const char = text[i];\n            const nextChar = text[i + 1];\n\n            if (CanvasTextMetrics.isBreakingSpace(char, nextChar) || CanvasTextMetrics._isNewline(char))\n            {\n                if (token !== '')\n                {\n                    tokens.push(token);\n                    token = '';\n                }\n\n                tokens.push(char);\n\n                continue;\n            }\n\n            token += char;\n        }\n\n        if (token !== '')\n        {\n            tokens.push(token);\n        }\n\n        return tokens;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to customise which words should break\n     * Examples are if the token is CJK or numbers.\n     * It must return a boolean.\n     * @param _token - The token\n     * @param breakWords - The style attr break words\n     * @returns Whether to break word or not\n     */\n    public static canBreakWords(_token: string, breakWords: boolean): boolean\n    {\n        return breakWords;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It allows one to determine whether a pair of characters\n     * should be broken by newlines\n     * For example certain characters in CJK langs or numbers.\n     * It must return a boolean.\n     * @param _char - The character\n     * @param _nextChar - The next character\n     * @param _token - The token/word the characters are from\n     * @param _index - The index in the token of the char\n     * @param _breakWords - The style attr break words\n     * @returns whether to break word or not\n     */\n    public static canBreakChars(_char: string, _nextChar: string, _token: string, _index: number,\n        _breakWords: boolean): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n     *\n     * It is called when a token (usually a word) has to be split into separate pieces\n     * in order to determine the point to break a word.\n     * It must return an array of characters.\n     * @param token - The token to split\n     * @returns The characters of the token\n     * @see CanvasTextMetrics.graphemeSegmenter\n     */\n    public static wordWrapSplit(token: string): string[]\n    {\n        return CanvasTextMetrics.graphemeSegmenter(token);\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     * @param font - String representing the style of the font\n     * @returns Font properties object\n     */\n    public static measureFont(font: string): FontMetrics\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (CanvasTextMetrics._fonts[font])\n        {\n            return CanvasTextMetrics._fonts[font];\n        }\n\n        const context = CanvasTextMetrics._context;\n\n        context.font = font;\n        const metrics = context.measureText(CanvasTextMetrics.METRICS_STRING + CanvasTextMetrics.BASELINE_SYMBOL);\n\n        const properties = {\n            ascent: metrics.actualBoundingBoxAscent,\n            descent: metrics.actualBoundingBoxDescent,\n            fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n        };\n\n        CanvasTextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n\n    /**\n     * Clear font metrics in metrics cache.\n     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n     */\n    public static clearMetrics(font = ''): void\n    {\n        if (font)\n        {\n            delete CanvasTextMetrics._fonts[font];\n        }\n        else\n        {\n            CanvasTextMetrics._fonts = {};\n        }\n    }\n\n    /**\n     * Cached canvas element for measuring text\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _canvas(): ICanvas\n    {\n        if (!CanvasTextMetrics.__canvas)\n        {\n            let canvas: ICanvas;\n\n            try\n            {\n                // OffscreenCanvas2D measureText can be up to 40% faster.\n                const c = new OffscreenCanvas(0, 0);\n                const context = c.getContext('2d', contextSettings);\n\n                if (context?.measureText)\n                {\n                    CanvasTextMetrics.__canvas = c as ICanvas;\n\n                    return c as ICanvas;\n                }\n\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            catch (_cx)\n            {\n                canvas = DOMAdapter.get().createCanvas();\n            }\n            canvas.width = canvas.height = 10;\n            CanvasTextMetrics.__canvas = canvas;\n        }\n\n        return CanvasTextMetrics.__canvas;\n    }\n\n    /**\n     * TODO: this should be private, but isn't because of backward compat, will fix later.\n     * @ignore\n     */\n    public static get _context(): ICanvasRenderingContext2D\n    {\n        if (!CanvasTextMetrics.__context)\n        {\n            CanvasTextMetrics.__context = CanvasTextMetrics._canvas.getContext('2d', contextSettings);\n        }\n\n        return CanvasTextMetrics.__context;\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { Container } from '../container/Container';\nimport type { HTMLText } from './HTMLText';\nimport type { HTMLTextStyle } from './HTMLTextStyle';\n\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _gpuText: Record<number, {\n        textureNeedsUploading: boolean;\n        generatingTexture: boolean;\n        texture: Texture,\n        currentKey: string,\n        batchableSprite: BatchableSprite,\n    }> = Object.create(null);\n\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.resolutionChange.add(this);\n        this._renderer.renderableGC.addManagedHash(this, '_gpuText');\n    }\n\n    public resolutionChange()\n    {\n        for (const i in this._gpuText)\n        {\n            const gpuText = this._gpuText[i];\n\n            if (!gpuText) continue;\n\n            const text = gpuText.batchableSprite.renderable as HTMLText;\n\n            if (text._autoResolution)\n            {\n                text._resolution = this._renderer.resolution;\n                text.onViewUpdate();\n            }\n        }\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText._getKey();\n\n        if (gpuText.textureNeedsUploading)\n        {\n            gpuText.textureNeedsUploading = false;\n\n            return true;\n        }\n\n        if (gpuText.currentKey !== newKey)\n        {\n            // TODO - could look into optimising this a tad!\n            // if its a single texture, then we could just swap it?\n            // same for CanvasText..\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateText(htmlText);\n        }\n\n        batchableSprite._batcher.updateElement(batchableSprite);\n    }\n\n    public destroyRenderable(htmlText: HTMLText)\n    {\n        htmlText.off('destroyed', this._destroyRenderableBound);\n        this._destroyRenderableById(htmlText.uid);\n    }\n\n    private _destroyRenderableById(htmlTextUid: number)\n    {\n        const gpuText = this._gpuText[htmlTextUid];\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        BigPool.return(gpuText.batchableSprite);\n\n        this._gpuText[htmlTextUid] = null;\n    }\n\n    private _updateText(htmlText: HTMLText)\n    {\n        const newKey = htmlText._getKey();\n        const gpuText = this._getGpuText(htmlText);\n        const batchableSprite = gpuText.batchableSprite;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n        }\n\n        htmlText._didTextUpdate = false;\n\n        updateTextBounds(batchableSprite, htmlText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const gpuText = this._getGpuText(htmlText);\n\n        if (gpuText.generatingTexture) return;\n\n        const newKey = htmlText._getKey();\n\n        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);\n\n        gpuText.generatingTexture = true;\n\n        gpuText.currentKey = newKey;\n\n        const resolution = htmlText.resolution ?? this._renderer.resolution;\n\n        const texture = await this._renderer.htmlText.getManagedTexture(\n            htmlText.text,\n            resolution,\n            htmlText._style as HTMLTextStyle,\n            htmlText._getKey()\n        );\n\n        const batchableSprite = gpuText.batchableSprite;\n\n        batchableSprite.texture = gpuText.texture = texture;\n\n        gpuText.generatingTexture = false;\n\n        gpuText.textureNeedsUploading = true;\n        htmlText.onViewUpdate();\n\n        updateTextBounds(batchableSprite, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const gpuTextData: HTMLTextPipe['_gpuText'][number] = {\n            texture: Texture.EMPTY,\n            currentKey: '--',\n            batchableSprite: BigPool.get(BatchableSprite),\n            textureNeedsUploading: false,\n            generatingTexture: false,\n        };\n\n        const batchableSprite = gpuTextData.batchableSprite;\n\n        batchableSprite.renderable = htmlText;\n        batchableSprite.transform = htmlText.groupTransform;\n        batchableSprite.texture = Texture.EMPTY;\n        batchableSprite.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableSprite.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        this._gpuText[htmlText.uid] = gpuTextData;\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        htmlText.on('destroyed', this._destroyRenderableBound);\n\n        return gpuTextData;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuText)\n        {\n            this._destroyRenderableById(i as unknown as number);\n        }\n\n        this._gpuText = null;\n        this._renderer = null;\n    }\n}\n\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\nexport const nssvg = 'http://www.w3.org/2000/svg';\nexport const nsxhtml = 'http://www.w3.org/1999/xhtml';\n\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HTMLTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: ConvertedStrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { generateTextStyleKey } from '../text/utils/generateTextStyleKey';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillInput, StrokeInput } from '../graphics/shared/FillTypes';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends {@link TextStyle}.\n * @memberof text\n * @extends text.TextStyleOptions\n * @property {string[]} [cssOverrides] - CSS style(s) to add.\n * @property {Record<string, text.HTMLTextStyleOptions>} [tagStyles] - Tag styles.\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' >\n{\n    cssOverrides?: string[];\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @memberof text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * List of styles per tag.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides ??= options.cssOverrides;\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /** List of style overrides that will be applied to the HTML text. */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    protected override _generateKey(): string\n    {\n        this._styleKey = generateTextStyleKey(this) + this._cssOverrides.join('-');\n\n        return this._styleKey;\n    }\n\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * @returns New cloned HTMLTextStyle object\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n        });\n    }\n\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    override set fill(value: FillInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    override set stroke(value: StrokeInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\nexport interface FontCSSStyleOptions\n{\n    fontFamily: string | string[]\n    fontWeight: string\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: style.fontWeight,\n                        fontStyle: style.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData ||= tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HTMLTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\nimport type { FontCSSStyleOptions } from './utils/loadFontCSS';\n\ninterface HTMLTextTexture\n{\n    texture: Texture,\n    usageCount: number,\n    promise: Promise<Texture>,\n}\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @memberof rendering\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    public static defaultFontOptions: FontCSSStyleOptions = {\n        fontFamily: 'Arial',\n        fontStyle: 'normal',\n        fontWeight: 'normal',\n    };\n\n    private _activeTextures: Record<string, HTMLTextTexture> = {};\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(\n            options.text as string,\n            options.resolution,\n            options.style as HTMLTextStyle\n        );\n    }\n\n    public getManagedTexture(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n        textKey: string\n    ): Promise<Texture>\n    {\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text, resolution, style)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    private async _buildTexturePromise(\n        text: string,\n        resolution: number,\n        style: HTMLTextStyle,\n    )\n    {\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: HTMLImageElement | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        // TODO SHOULD NOT BE NEEDED\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    private _cleanUp(activeTexture: HTMLTextTexture)\n    {\n        TexturePool.returnTexture(activeTexture.texture);\n        activeTexture.texture.source.resource = null;\n        activeTexture.texture.source.uploadMethodId = 'unknown';\n    }\n\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey].usageCount;\n    }\n\n    public destroy(): void\n    {\n        this._activeTextures = null;\n    }\n}\n","import type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { DOMAdapter } from '../../environment/adapter';\n\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const canvas = canvasAndContext.canvas;\n        const { width, height } = canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        canvasAndContext.context.clearRect(0, 0, width, height);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @memberof scene\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. If not provided, they will be filled with 0 and match the size of the positions. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @memberof scene\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {scene.MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n\n        let uvs = options.uvs;\n\n        if (!uvs)\n        {\n            if (options.positions)\n            {\n                uvs = new Float32Array(positions.length);\n            }\n            else\n            {\n                uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n            }\n        }\n\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the positions of the mesh.\n     * When setting the positions, its important that the uvs array is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The positions of the mesh.\n     */\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the UVs of the mesh.\n     * Its important that the uvs array you set is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The UVs of the mesh.\n     */\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n"],"names":["localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","tilingBit","fragment","tilingBitGl","gpuProgram","glProgram","TilingSpriteShader","Shader","constructor","compileHighShaderGpuProgram","bits","roundPixelsBit","compileHighShaderGlProgram","roundPixelsBitGl","tilingUniforms","UniformGroup","uMapCoord","value","Matrix","type","uClampFrame","Float32Array","uClampOffset","uTextureTransform","uSizeAnchor","resources","localUniforms","uTransformMatrix","uColor","uRound","uTexture","Texture","EMPTY","source","uSampler","style","updateUniforms","width","height","matrix","anchorX","anchorY","texture","this","textureWidth","textureHeight","textureMatrix","uniforms","set","a","b","c","d","tx","ty","invert","mapCoord","QuadGeometry","MeshGeometry","positions","uvs","indices","Uint32Array","sharedQuad","TilingSpritePipe","renderer","_state","State","default2d","_tilingSpriteDataHash","Object","create","_destroyRenderableBound","destroyRenderable","bind","_renderer","renderableGC","addManagedHash","validateRenderable","renderable","tilingSpriteData","_getTilingSpriteData","couldBatch","canBatch","_updateCanBatch","batchableMesh","_batcher","checkAndUpdateTexture","addRenderable","tilingSprite","instructionSet","batcher","renderPipes","batch","geometry","BatchableMesh","didViewUpdate","_updateBatchableMesh","transform","groupTransform","setTexture","_texture","roundPixels","_roundPixels","addToBatch","break","shader","updateRenderable","add","execute","uid","groups","globalUniforms","bindGroup","color32BitToUniform","groupColorAlpha","blendMode","getAdjustedBlendModeBlend","groupBlendMode","_source","encoder","draw","state","updateElement","_tileTransform","anchor","x","y","destroy","off","_initTilingSpriteData","slice","on","renderableData","addressMode","update","frame","applyAnchorToTexture","shared","copyFrom","scale","array","stride","offset","index","size","length","applyMatrix","setUvs","setPositions","i","_nonPowOf2wrapping","RendererType","WEBGL","context","supports","nonPowOf2wrapping","isSimple","isPowerOfTwo","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","extensions","batcherName","packAsQuad","indexOffset","attributeOffset","_batch","_textureMatrixUpdateId","_uvUpdateId","topology","_topology","reset","uvBuffer","getBuffer","data","transformedUvs","_transformedUvs","_updateID","multiplyUvs","color","attributeSize","indexSize","blendModeIds","normal","multiply","screen","overlay","erase","min","max","_State","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","ResizePlugin","init","options","defineProperty","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","get","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","window","innerWidth","innerHeight","clientWidth","clientHeight","render","resizeTo","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","remove","UPDATE_PRIORITY","LOW","stop","start","Ticker","oldTicker","BatchableSprite","_attributeStart","bounds","GraphicsPipe","adaptor","_graphicsBatchesHash","_adaptor","graphics","wasBatched","gpuContext","graphicsContext","updateGpuContext","isBatchable","_rebuild","_addToBatcher","batches","_removeBatchForRenderable","isRenderable","getGpuContext","customShader","_initBatchesForRenderable","batched","batchPipe","_getBatchesForRenderable","map","batchClone","BigPool","BatchableGraphics","copyTo","graphicsUid","forEach","return","GraphicsContextSystem","genericFontFamilies","fontStringFromTextStyle","fontSizeString","fontSize","fontFamilies","fontFamily","Array","isArray","split","trim","test","includes","fontStyle","fontVariant","fontWeight","join","_TextStyle","EventEmitter","arguments","undefined","oldStyle","dropShadow","defaults","TextStyle","defaultDropShadow","alpha","dropShadowAlpha","angle","dropShadowAngle","blur","dropShadowBlur","dropShadowColor","distance","dropShadowDistance","strokeThickness","deprecation","v8_0_0","stroke","obj","Color","isColorLike","FillGradient","FillPattern","fill","hasOwnProperty","call","Error","fillGradientStops","defaultTextStyle","parseInt","gradientFill","fills","setValue","toNumber","number","ratio","addColorStop","convertV7Tov8Style","fullStyle","key","align","_align","breakWords","_breakWords","_dropShadow","_createProxy","_fontFamily","_fontSize","_fontStyle","toLowerCase","_fontVariant","_fontWeight","leading","_leading","letterSpacing","_letterSpacing","lineHeight","_lineHeight","padding","_padding","_trim","textBaseline","_textBaseline","whiteSpace","_whiteSpace","wordWrap","_wordWrap","wordWrapWidth","_wordWrapWidth","_originalFill","_isFillStyle","GraphicsContext","defaultFillStyle","_fill","toFillStyle","_originalStroke","defaultStrokeStyle","_stroke","toStrokeStyle","_generateKey","_styleKey","generateTextStyleKey","emit","defaultStyle","styleKey","clone","removeAllListeners","destroyTextureSource","textureSource","cb","Proxy","target","property","newValue","Math","PI","CanvasTextPipe","_gpuText","runners","resolutionChange","gpuText","text","batchableSprite","_autoResolution","_resolution","resolution","onViewUpdate","_getGpuText","newKey","_getKey","currentKey","_didTextUpdate","_updateText","_destroyRenderableById","textUid","canvasText","decreaseReferenceCount","_updateGpuText","updateTextBounds","getManagedTexture","initGpuText","gpuTextData","minX","maxX","minY","maxY","checkRow","checkColumn","top","bottom","CanvasTextSystem","_activeTextures","getTextureSize","measured","CanvasTextMetrics","measureText","ceil","nextPow2","getTexture","_textKey","canvasAndContext","createTextureAndCanvas","initSource","CanvasPool","returnCanvasAndContext","getOptimalCanvasAndContext","canvas","renderTextToCanvas","getPo2TextureFromSource","trimmed","getContext","willReadFrequently","TypeError","getImageData","left","right","Rectangle","getCanvasBoundingBox","updateUvs","textKey","_increaseReferenceCount","usageCount","returnTexture","resource","uploadMethodId","alphaMode","TexturePool","activeTexture","getReferenceCount","font","lines","lineWidths","maxLineWidth","fontProperties","resetTransform","strokeStyle","lineWidth","miterLimit","lineJoin","lineCap","cap","linePositionX","linePositionY","passesCount","isShadowPass","dsOffsetText","dsOffsetShadow","fillStyle","shadowOptions","shadowColor","setAlpha","toRgbaString","shadowBlur","shadowOffsetX","cos","shadowOffsetY","sin","getCanvasFillStyle","alignment","linePositionYShift","strokeWidth","i2","ascent","_drawLetterSpacing","isStroke","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","strokeText","fillText","currentPosition","stringArray","graphemeSegmenter","previousWidth","currentWidth","currentChar","textStr","j","WebGLSystem","WebGPUSystem","CanvasSystem","localUniformMSDFBit","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","uDistance","maxTextures","getMaxTexturesPerBatch","colorBit","generateTextureBatchBit","colorBitGl","generateTextureBatchBitGl","batchSamplers","getBatchSamplersUniformGroup","AbstractBitmapFont","chars","fontMetrics","descent","baseLineOffset","distanceField","range","pages","applyFillAsTint","baseMeasurementFontSize","baseRenderedFontSize","pageTextures","distanceFieldRange","distanceFieldType","destroyTextures","page","resolveCharacters","result","item","startCode","charCodeAt","endCode","j2","push","String","fromCharCode","from","_DynamicBitmapFont","_measureCache","_currentChars","_currentX","_currentY","_currentPageIndex","_skipKerning","dynamicOptions","defaultOptions","_textureSize","textureSize","_mipmap","mipmap","overrideFill","WHITE","requestedFontSize","overrideSize","_style","skipKerning","measureFont","ensureCharacters","charList","filter","char","self","indexOf","pageData","_nextPage","currentX","currentY","fontScale","maxCharHeight","skipTexture","maxTextureWidth","maxTextureHeight","metrics","paddedWidth","paddedHeight","pageData2","xAdvance","id","codePointAt","xOffset","yOffset","kerning","_drawGlyph","px","py","_applyKerning","newChars","measureCache","first","second","c1","c2","total","amount","textureResolution","_setupContext","ImageSource","autoGenerateMipmaps","rgb","toArray","super","DynamicBitmapFont","getBitmapTextLayout","trimEnd","layoutData","offsetY","charPositions","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","position","nextLine","lastChar","adjustedLetterSpacing","adjustedWordWrapWidth","isEnd","charData","nextCharWidth","measurementData","line","alignCenter","alignRight","indy","spaceIndex","totalSpaces","alignJustify","fontCount","BitmapFontManager","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","getFont","fontFamilyKey","substring","lastIndexOf","Cache","has","fnt","warn","once","dynamicFont","getLayout","bitmapFont","install","textStyle","flatChars","uninstall","cacheKey","BitmapTextPipe","_gpuBitmapText","bitmapText","graphicsRenderable","_getGpuBitmapText","_updateContext","syncWithProxy","_updateDistanceField","_destroyRenderableByUid","renderableUid","proxyGraphics","clear","bitmapTextLayout","translate","_anchor","_x","_y","tint","round","proxyRenderable","Graphics","dx","sqrt","dy","worldScale","abs","container","proxy","groupColor","globalDisplayStatus","localDisplayStatus","groupAlpha","valuesToIterateForKeys","prop","addFillStyleKey","addStokeStyleKey","addDropShadowKey","MeshPipe","localUniformsBindGroup","BindGroup","_meshDataHash","_gpuBatchableMeshHash","mesh","meshData","_getMeshData","isBatched","_geometry","vertexSize","_getBatchableMesh","gpuBatchableMesh","gpuMesh","_initMeshData","_initBatchableMesh","tempBounds","Bounds","image","getOptimalTexture","_PlaneGeometry","verticesX","verticesY","build","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","indexBuffer","PlaneGeometry","_NineSliceGeometry","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","_anchorX","_anchorY","updatePositions","p","w","scaleW","h","scaleH","anchorOffsetX","anchorOffsetY","_uvw","_uvh","NineSliceGeometry","NineSliceSpritePipe","_gpuSpriteHash","sprite","gpuSprite","_getGpuSprite","_updateBatchableSprite","_initGPUSprite","FilterPipe","filterEffect","renderPipeId","canBundle","action","pop","_filterEffect","_container","instruction","quadGeometry","Geometry","attributes","aPosition","buffer","format","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","uInputSize","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","activeBackTexture","_activeFilterData","backTexture","filters","_getFilterData","filterData","skip","renderables","tempMatrix","worldTransform","addBounds","getGlobalRenderableBounds","filterArea","addRect","getFastGlobalBounds","filterFrameTransform","renderGroup","parentRenderGroup","cacheToLocalTransform","colorTextureSource","renderTarget","colorTexture","Infinity","antialias","blendRequired","enabled","clipToViewport","compatibleRenderers","backBuffer","useBackBuffer","viewPort","rootViewPort","rootResolution","fitBounds","pad","isPositive","previousRenderSurface","renderSurface","inputTexture","finishRenderPass","previousBounds","getRenderTarget","getBackTexture","setResource","apply","flip","flop","t","lastRenderSurface","backgroundResolution","floor","copyToTexture","applyFilter","input","output","Point","isFinalTarget","rootRenderTarget","currentIndex","filterUniforms","outputFrame","inputSize","inputPixel","inputClamp","globalFrame","outputTexture","lastIndex","filterData2","pixelWidth","pixelHeight","rootTexture","isRoot","uniformBatch","batchUniforms","getUboResource","calculateSpriteMatrix","outputMatrix","mappedMatrix","prepend","GlParticleContainerAdaptor","particleContainerPipe","defaultShader","gl","getBuffers","glType","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","createIndicesForQuads","outBuffer","totalIndices","Uint16Array","generateUpdateFunction","properties","dynamic","funcFragments","code","getAttributeInfoFromFormat","unshift","functionSource","Function","ParticleBuffer","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","Buffer","label","shrinkToFit","usage","BufferUsage","VERTEX","COPY_DST","_dynamicBuffer","addAttribute","attributeName","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","setDataWithSize","byteLength","float32View","uint32View","ParticleShader","GlProgram","GpuProgram","wgsl","entryPoint","TextureStyle","uTranslationMatrix","uResolution","ParticleContainerPipe","_gpuBufferHash","_renderable","_initBuffer","_properties","children","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","GpuParticleContainerPipe","PRECISION","textMetrics","toHexa","pattern","createPattern","setTransform","fillPattern","fillGradient","isLinear","isLocal","textureSpace","gradient","isNearlyVertical","createLinearGradient","center","innerRadius","outerCenter","outerRadius","createRadialGradient","colorStops","globalStop","toHex","updateQuadBounds","contextSettings","_CanvasTextMetrics","_experimentalLetterSpacingSupported","proto","DOMAdapter","getCanvasRenderingContext2D","prototype","_canvas","_measurementCache","__context","_measureText","metricWidth","actualBoundingBoxLeft","boundsWidth","actualBoundingBoxRight","val","cache","collapseSpaces","_collapseSpaces","collapseNewlines","_collapseNewlines","canPrependSpaces","tokens","_tokenize","token","_isNewline","_addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","_getFromCache","canBreakWords","characters","wordWrapSplit","k","nextChar","canBreakChars","characterWidth","isLastToken","newLine","_trimRight","_newlines","_nextChar","_breakingSpaces","_token","_char","_index","_fonts","_context","METRICS_STRING","BASELINE_SYMBOL","actualBoundingBoxAscent","actualBoundingBoxDescent","clearMetrics","__canvas","OffscreenCanvas","createCanvas","_cx","BASELINE_MULTIPLIER","HEIGHT_MULTIPLIER","Intl","Segmenter","segmenter","s","segment","HTMLTextPipe","htmlText","textureNeedsUploading","htmlTextUid","catch","e","console","error","generatingTexture","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","Image","setAttribute","overflow","appendChild","textStyleToCSS","cssStyles","strokeToCSS","dropShadowToCSS","cssOverrides","tagStyles","out","tagStyle","cssTagStyle","templates","tagStyleToCSS","dropShadowStyle","HTMLTextStyle","_cssOverrides","_cssStyle","cssStyle","addOverride","_len","_key","toAdd","v","removeOverride","_len2","_key2","toRemove","loadFontCSS","url","dataSrc","response","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","onerror","readAsDataURL","loadFontAsBase64","FontStylePromiseCache","Map","tempHTMLTextRenderData","HTMLTextSystem","_createCanvas","WEBGPU","_buildTexturePromise","promise","then","htmlTextData","dedupe","matches","match","addFontFamily","fontFamily2","extractFontFamilies","fontCSS","fontPromises","all","getFontCss","fontStyleCSS","htmlTextRenderData","innerHTML","textContent","body","contentBounds","getBoundingClientRect","doublePadding","measureHtmlText","svgURL","XMLSerializer","serializeToString","getSVGUrl","delay","async","resolve2","setTimeout","onload","src","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","isSafari","clearRect","drawImage","getTemporaryCanvasFromImage","_cleanUp","defaultFontOptions","abgr","canvasOptions","_canvasPool","enableFullScreen","_createCanvasAndContext","minWidth","minHeight","_MeshGeometry","shrinkBuffersToFit","aUV","INDEX","batchMode"],"sourceRoot":""}